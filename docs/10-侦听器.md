## 侦听器

在某些状态变化时执行副作用

```js
watch(
  watchStatus,
  async (newStatus, oldStatus) => {
    await fetch('...')
  },
  {
    once: false,
    immediate: false
  }
)
```

`watch` 第一个参数可以是

- 单个 ref，不能直接侦听一个属性值，传入的是响应式对象会隐式创建一个深层侦听器，侦听所有嵌套属性（性能开销大）
- getter 函数（返回一个值的函数），在函数返回不同值时触发更新
- 多个来源组成的数组

不能直接侦听响应式对象的属性值

设置第三个参数

- `immediate: true` 强制侦听器立即执行一次（默认是懒执行，创建时不会执行）
- `once: true` 只执行一次

### watchEffect()

会自动跟踪回调的响应式依赖，不需要手动维护依赖列表，不需要指定 `immediate: true` 回调就会立即执行

`watch` 不会追踪没有明确侦听的数据源，可以更加精确控制执行时机
`watchEffect` 书写更方便简洁

### 执行时机

更改了响应式状态后，可能会同时触发 DOM 更新和侦听器回调，而且可能会有多次（会被批量处理）
**默认情况下，在父组件更新之后，所属组件 DOM 更新之前被调用，在回调中访问所属组件 DOM，得到的是处于更新前的状态**

#### 后置更新

如果需要回调中访问更新后的 DOM，需要给 watch 或者 watchEffect 指明 `flush: 'post'`，或使用 `watchPostEffect()`

#### 同步更新

`flush: 'sync'` 会在 Vue 进行更新之前触发
`watchSyncEffect()`
同步侦听器不会进行批处理，需要小心性能问题

### 停止侦听器

类似于 React 的 useEffect destroy 函数

setup() 中用同步语句创建的侦听器，会自动绑定在宿主组件实例上，并在组件卸载时自动停止

如果是异步创建的，则不会绑定到当前组件实例上，需要手动停止避免内存泄漏

直接调用 `watch` `watchEffect` 返回到 `unwatch` 函数即可

尽量使用同步创建侦听器，如果需要等待异步数据，可以在侦听器回调函数中加条件逻辑
