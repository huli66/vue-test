## 响应式基础

只用在 setup() 中暴露的变量和方法才能在模板自动解析和使用，无需额外的声明或导入
**在 `<script setup>` 中的顶层导入、声明的变量、函数 可以在同一组件的模板中直接使用，可以将模板理解为同一作用域内声明的一个 JS 函数--它可以自然地访问和它一起声明的所有内容**

### ref()

ref() 接受一个内部值，返回一个响应式的可更改的 ref 对象，此对象只有一个指向其内部值的属性 `.value`

没有使用 ref 直接声明的变量也可以被绑定，但是不会触发响应式更新

基于依赖追踪的响应式系统

**一个组件首次被渲染时，Vue 会追踪渲染过程中使用的每一个 ref，然后当一个 ref 被修改时，会触发追踪它的组件的一次重新渲染**

更改 ref 对象就是为 `.value` 赋值新内容，这个操作是响应式的，会被追踪，并且触发相关的副作用

- 在模板中访问 ref 不需要附加 `.value`，js 中使用则需要，在模板中也可以直接操作 ref，在模板中 ref 会自动解包

修改了响应式状态后DOM会被自动更新，但是 DOM 更新不是同步的，Vue 会在 'next tick' 更新周期中缓冲所有状态的修改，以确保不管进行了多少次状态修改，每个组件只会被更新一次，`await nextTick()` 后面的代码，会等待 DOM 更新完后再执行

**ref 可以持有任何类型的值包括深层嵌套的对象，ref 会使它的值具有深层响应性**

**如果将一个非原始值赋值给 ref，那么这个对象会通过 reactive() 转为具有深层次响应式的对象**

对象中包含了嵌套的 ref 将被深层次解包，可以用 shallowRef 来替代

**对于浅层 ref，只有 `.value` 的访问会被追踪**

### reactive()

reactive 标注类型直接写对象类型即可，不需要使用泛型

和 ref 不同，**reactive() 将使对象本身具有响应性**

reactive 将深层转换对象，访问嵌套对象时，也会被 `reactive()` 包装，当 `ref()` 的值是一个对象时，ref 内部也会调用 `reactive()`

对应的，也有 `shallowReactive()` 浅层转换响应式

- `reactive()` 返回的是一个原始对象的 `Proxy`
- 只有代理对象是响应式的，更改原始对象不会触发更新
  为了保证访问代理的一致性
- 对同一个原始对象调用 `reactive()` 返回的代理对象是同一个（单例）
- 对一个已存的代理对象调用，会返回它本身

#### reactive 的局限性

- 有限的值类型，不能用于原始类型，只能用于对象类型（object，array，map，set）
- 不能替换整个对象
  由于 Vue 响应式追踪是通过访问属性实现的，所以必须始终保持对响应式对象的相同引用，如果替换了响应式对象，则前一个响应式对象在模板中的使用不会更新（js中能读取到新的响应式对象值）

- 对解构操作不友好，把响应式对象的某一个**原始类型属性**解构出来，改变这个值不会触发更新，**如果解构出来的是一个深层的对象，那么其实还是会具有响应式的**

基于这些问题，建议还是使用 `ref()` 作为声明响应式状态的主要 api (ref 也不支持解构)

### 其他细节

- 与 reactive 不同，ref 作为数组或者对象的元素被访问时，不会被解包，需要使用 `.value` 读取，reactive 可以直接使用

**？？在数组项里要解包，在对象属性里不需要，为什么**

- 在模板语法中，只有顶级的 ref 才会被解包
  但是非顶级的 ref，如果作为文本插值的最终计算值，还是会被解包
  例子如下

```js
const count = ref(0)
const object = { id: ref(1) }

{
  {
    count + 1
  }
} // 1
{
  {
    object.id + 1
  }
} // [object Object]1
{
  {
    object.id
  }
} // 1
```
